<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
	<id>https://www.nyami.uk/</id>
	<title />
	<link rel="self" href="https://www.nyami.uk/" />
	<rights>Copyright © 2022</rights>
	<updated>2022-03-31T09:35:27Z</updated>
	<subtitle>Something interesting for sure...</subtitle>
	<entry>
		<id>https://www.nyami.uk/posts/2022/2022-03-31-verifying-calls-with-nsubstitute</id>
		<title>Verifying calls with NSubstitute</title>
		<link href="https://www.nyami.uk/posts/2022/2022-03-31-verifying-calls-with-nsubstitute" />
		<updated>2022-03-31T00:00:00Z</updated>
		<content>&lt;p&gt;This one came up recently so I thought I would do a post for my future self, so I have something to come back to. Being a conscientious developer &lt;a id="fnref:1" href="https://www.nyami.uk/#fn:1" class="footnote-ref"&gt;&lt;sup&gt;1&lt;/sup&gt;&lt;/a&gt; I was creating unit tests and I found a situation where I wanted to verify the call to a method was the expected call, in this case the functionality being tested was creating an object and then calling a repository to persist this, I needed to check the object being persisted was as I expected.&lt;/p&gt;
&lt;!--more--&gt;
&lt;p&gt;Here is a rather simplified example of what we want to test:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-CSharp"&gt;class MyThing {
    readonly IFoo foo;
    public MyThing(IFoo foo) {
        this.foo = foo;
    }

    public async Task&amp;lt;bool&amp;gt; DoTheThing(int howManyTimes) {
        var x = new List&amp;lt;int&amp;gt;();
        for (int i = 1; i &amp;lt;= howManyTimes; i++) {
            x.Add(i);
        }

        foo.DoSomething(x);
        return await Task.FromResult(true);
    }
}

public interface IFoo {
    void DoSomething(IList&amp;lt;int&amp;gt; list);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Using NSubstitute we can create a mock for IFoo using &lt;code&gt;NSubstitute.Substitute.For&amp;lt;IFoo&amp;gt;()&lt;/code&gt;, and now this can be used to verify calls using &lt;code&gt;Received()&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-CSharp"&gt;// Arrange
var foo = NSubstitute.Substitute.For&amp;lt;IFoo&amp;gt;();

// Act
var sut = new MyThing(foo);
await sut.DoTheThing(3);

// Assert
foo.Received().DoSomething(Arg.Is&amp;lt;IList&amp;lt;int&amp;gt;&amp;gt;(l =&amp;gt; l.Count() == 3));
foo.Received().DoSomething(Arg.Is&amp;lt;IList&amp;lt;int&amp;gt;&amp;gt;(l =&amp;gt; l.First() == 1));
foo.Received().DoSomething(Arg.Is&amp;lt;IList&amp;lt;int&amp;gt;&amp;gt;(l =&amp;gt; l.Last() == 3));
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We could alternatively pass in a function that could do some more complex checks, eg:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-CSharp"&gt;Func&amp;lt;IList&amp;lt;int&amp;gt;, bool&amp;gt; expectedResult = (list) =&amp;gt; { return false;};
foo.Received().DoSomething(Arg.Is&amp;lt;IList&amp;lt;int&amp;gt;&amp;gt;(l =&amp;gt; expectedResult(l)));
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;or we could even capture the arguments used using &lt;code&gt;Do&lt;/code&gt; by setting this up during our arrangement:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-CSharp"&gt;IList&amp;lt;int&amp;gt; captured = null!;
foo.When(substitute =&amp;gt; substitute.DoSomething(Arg.Any&amp;lt;IList&amp;lt;int&amp;gt;&amp;gt;())).Do(info =&amp;gt; captured = info.ArgAt&amp;lt;IList&amp;lt;int&amp;gt;&amp;gt;(0));
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;NSubstitute can do a whole lot more and you could really go to town with some of the functionality, if you are not familiar with it I would encourage you to check it out - &lt;a href="https://nsubstitute.github.io/"&gt;https://nsubstitute.github.io/&lt;/a&gt;&lt;/p&gt;
&lt;div class="footnotes"&gt;
&lt;hr&gt;
&lt;ol&gt;
&lt;li id="fn:1"&gt;
&lt;p&gt;I do try most of the time&lt;a href="https://www.nyami.uk/#fnref:1" class="footnote-back-ref"&gt;↩&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
</content>
		<summary>Something interesting for sure...</summary>
	</entry>
	<entry>
		<id>https://www.nyami.uk/posts/2022/2022-03-04-sln-wide-project-settings</id>
		<title>Solution Wide Project Settings</title>
		<link href="https://www.nyami.uk/posts/2022/2022-03-04-sln-wide-project-settings" />
		<updated>2022-03-04T00:00:00Z</updated>
		<content>&lt;p&gt;When working with larger solutions in Visual Studio there often common properties you want to set across the board for all your project, for example &lt;code&gt;Copyright&lt;/code&gt; or &lt;code&gt;TreatWarningsAsErrors&lt;/code&gt;. It can be a little tedious to set these for all the projects, particularly for bigger solutions, and when you add new projects to your solution it's easily missed resulting in undesired differences between projects. A nice simple way to set common properties is to use &lt;code&gt;Directory.Build.props&lt;/code&gt;.&lt;/p&gt;
&lt;!--more--&gt;
&lt;p&gt;Simply create a new file, &lt;code&gt;Directory.Build.props&lt;/code&gt;, at the root of your solution and populate it with the properties you wish to set, for example:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-xml"&gt;&amp;lt;Project&amp;gt;
  &amp;lt;PropertyGroup&amp;gt;
    &amp;lt;TreatWarningsAsErrors&amp;gt;True&amp;lt;/TreatWarningsAsErrors&amp;gt;
    &amp;lt;Copyright&amp;gt;Douglas Cameron&amp;lt;/Copyright&amp;gt;
  &amp;lt;/PropertyGroup&amp;gt;
&amp;lt;/Project&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now all projects under this folder will take on these properties, and they can be overridden, or indeed expanded with another &lt;code&gt;Directory.Build.props&lt;/code&gt; within any subfolder (for example if your unit tests are under a test folder, you could create properties pertaining to these projects there), or via the actual project file.&lt;/p&gt;
&lt;p&gt;You could also this file to add common NuGet packages to all your projects, for example if you used &lt;a href="https://docs.microsoft.com/en-us/dotnet/fundamentals/code-analysis/overview#third-party-analyzers"&gt;3rd party analyzers&lt;/a&gt; you could add these here along with any custom rules as required, however you will need to manage the version here and avoid using the NuGet package manager in Visual Studio as this will affect the actual project files.&lt;/p&gt;
</content>
		<summary>Something interesting for sure...</summary>
	</entry>
	<entry>
		<id>https://www.nyami.uk/posts/2020-05-04-unittestentitybuilder</id>
		<title>Entity Builder for Unit Tests</title>
		<link href="https://www.nyami.uk/posts/2020-05-04-unittestentitybuilder" />
		<updated>2020-05-04T00:00:00Z</updated>
		<content>&lt;p&gt;If you find yourself needing to create an instance of a domain entity for unit testing, but having trouble getting round property or constructor accessability, using a builder is a great technique to get round this and provide a consistent, reusable method of creating the object for your tests.&lt;/p&gt;
&lt;!--more--&gt;
&lt;p&gt;Typically you might find yourself creating opinionated constructors or getter only properties that will assert or support rules for an entity or business logic, but these can sometimes present a challenge when it comes to creating unit tests. Consider the following class:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Foo
{
  public enum StatusEnum
  {
    New = 0,
    Open = 1,
    Closed = 2
  }

  // Private constructor used by Entity Framework
  private Foo() { }

  // Used to create a new Foo
  public Foo(string name)
  {
    if (string.IsNullOrWhiteSpace(name)) throw new ArgumentException(&amp;quot;Name must not be empty&amp;quot;, nameof(name));
    this.Name = name;
    this.Status = StatusEnum.New;
  }

  public string Name { get; private set; }
  public StatusEnum Status { get; private set; }

  public void Close() {
    if (this.Status != StatusEnum.Open) throw new Exception($&amp;quot;{this.Name} must be open for it to be closed.&amp;quot;);

    this.Status = StatusEnum.Closed;
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Here we have our Foo entity designed to assert a couple of things, firstly we can only set the name when creating the instance, and secondly we can only change the status to Closed if the status is currently Open. If we wanted to write a unit test around our &lt;code&gt;Close&lt;/code&gt; method we might be tempted to change the accessability of our &lt;code&gt;Status&lt;/code&gt; property, or even change the private constructor to allow us to create a usable entity in our test project, however both these actions might well lead to an API open to misuse.&lt;/p&gt;
&lt;p&gt;A much better option would be to create a builder in our test project which can easily get round the constructor and property accessability and ensure some sort of consistency and reusability in our unit tests. Our builder for the class above might look a little like this:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class FooBuilder
{
  private readonly Type entityType = typeof(Foo);
  private readonly Foo foo;

  public FooBuilder(string name)
  {
    var entity = Activator.CreateInstance(entityType, true) as Foo;
    foo = entity ?? throw new ArgumentNullException(nameof(entity));
    entityType.GetProperty(nameof(foo.Name)).SetValue(foo, name);
  }

  public FooBuilder WithStatus(StatusEnum status)
  {
    entityType.GetProperty(nameof(foo.Status)).SetValue(foo, status);
    return this;
  }

  public Foo Build()
  {
    return foo;
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We can now use this builder to create and bypass our assertions without compromising the design of our entity:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var testFoo = new FooBuilder(&amp;quot;wibble&amp;quot;)
  .WithStatus(StatusEnum.Open)
  .Build();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This is not fool proof and still open for misuse, but at least most of the damage will confined to your test projects so it's a much better option compared to 'compromising' your API design.&lt;/p&gt;
</content>
		<summary>Something interesting for sure...</summary>
	</entry>
	<entry>
		<id>https://www.nyami.uk/posts/2019-06-11-vuewithaspnetpart3</id>
		<title>VueJs and ASP.NET Core - Part 3</title>
		<link href="https://www.nyami.uk/posts/2019-06-11-vuewithaspnetpart3" />
		<link rel="enclosure" type="image" href="https://www.nyami.uk/images/VueLogo.png" />
		<updated>2019-06-11T00:00:00Z</updated>
		<content>&lt;p&gt;In parts &lt;a href="https://www.nyami.uk/posts/2019-05-10-VueWithAspNetPart1"&gt;1&lt;/a&gt; and &lt;a href="https://www.nyami.uk/posts/2019-05-21-VueWithAspNetPart2"&gt;2&lt;/a&gt; we looked at the experience of creating a new Angular app and some of the differences compared to what's required for Vue. We then went on to create middleware to add support for running the Vue CLI within our ASP.NET application, and then a new project enabling us to successfully run the Vue CLI in development and have the ability to package everything together when publishing our app. In this final part we are going to create a new project template allowing us a quick start for future projects.&lt;/p&gt;
&lt;!--more--&gt;
&lt;h2 id="creating-a-template"&gt;Creating a Template&lt;/h2&gt;
&lt;p&gt;Newer versions of the .NET SDK has really simplified template creation, rather than detailing the whole experience here you are probably best referring to the &lt;a href="https://docs.microsoft.com/en-us/dotnet/core/tutorials/create-custom-template"&gt;official documentation&lt;/a&gt; however here is an overview of what I've done with a few handy pointers.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Create an empty project based on the webapi template&lt;/li&gt;
&lt;li&gt;Added the package created in Part 2 using &lt;code&gt;Install-Package Nyami.AspNetCore.VueCliServices&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Created a ClientApp using the Vue CLI&lt;/li&gt;
&lt;li&gt;Added the custom targets into the project file&lt;/li&gt;
&lt;li&gt;Created the template configuration described &lt;a href="https://docs.microsoft.com/en-us/dotnet/core/tutorials/create-custom-template#create-a-template-from-a-project"&gt;here&lt;/a&gt;
&lt;ol&gt;
&lt;li&gt;When creating the template specify &lt;code&gt;sourceName&lt;/code&gt;, this should match your root namespace and project file name, when a project is created from the template this will be replaced with the name&lt;/li&gt;
&lt;li&gt;&lt;code&gt;preferNameDirectory&lt;/code&gt; was set to &lt;code&gt;true&lt;/code&gt;, if no name is provided when the project is created the folder name will be used as the default name&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;Made some minor changes to the wiring everything up in a more realistic way
&lt;ol&gt;
&lt;li&gt;Place holders for config&lt;/li&gt;
&lt;li&gt;Add a call to the API from the Vue component&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;Created nuspec file
&lt;ol&gt;
&lt;li&gt;Ensure the generated files (bin, obj, node_modules etc) were excluded from the package&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;Published to NuGet&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;This template can be pulled down from NuGet and installed using the command &lt;code&gt;dotnet new -i Nyami.AspNetCore.Vue.Template&lt;/code&gt;, once installed you can create a new project using &lt;code&gt;dotnet new vue&lt;/code&gt;.&lt;/p&gt;
&lt;h2 id="summary"&gt;Summary&lt;/h2&gt;
&lt;p&gt;There are a number of ways to get Vue.js and ASP.NET working together but this approach to works really well allowing you to get up and running with minimal effort and take advantage of Vue's CLI along side Visual Studio's developer experience. I'm not expecting either packages to get a lot of use, they were mainly proving the concept, but if you end up using them and have problems or questions just reach out to me.&lt;/p&gt;
</content>
		<summary>Something interesting for sure...</summary>
	</entry>
	<entry>
		<id>https://www.nyami.uk/posts/2019-05-21-vuewithaspnetpart2</id>
		<title>VueJs and ASP.NET Core - Part 2</title>
		<link href="https://www.nyami.uk/posts/2019-05-21-vuewithaspnetpart2" />
		<link rel="enclosure" type="image" href="https://www.nyami.uk/images/VueLogo.png" />
		<updated>2019-05-21T00:00:00Z</updated>
		<content>&lt;p&gt;In &lt;a href="https://www.nyami.uk/posts/2019-05-10-VueWithAspNetPart1"&gt;Part 1&lt;/a&gt; we looked at the Angular project template with ASP.NET Core and its pretty much what we want to achieve for VueJs. In this part we'll dig a little deeper into &lt;a href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.spaservices?view=aspnetcore-2.2"&gt;Microsoft.AspNetCore.SpaServices&lt;/a&gt;, specifically &lt;a href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.spaservices.angularcli?view=aspnetcore-2.2"&gt;Microsoft.AspNetCore.SpaServices.AngularCli&lt;/a&gt; and look to take inspiration for our Vue solution.&lt;/p&gt;
&lt;!--more--&gt;
&lt;h2 id="vue-create"&gt;vue create&lt;/h2&gt;
&lt;p&gt;Let's start out by trying to use the template created for Angular and swap out the ClientApp for our VueJs app and see what happens.
First we'll create our VueJs application, to do this we'll use the &lt;a href="https://cli.vuejs.org/"&gt;Vue CLI&lt;/a&gt;, I've used npm to install this as a global tool (&lt;code&gt;npm install -g @vue/cli&lt;/code&gt;), so it just a case of typing &lt;code&gt; vue create hello-world&lt;/code&gt;, where hello-world is the name of your project, at a suitable location in your favourite command prompt. You'll then be prompted a present, I opted for manually selecting feature and chose:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Babel, TypeScript, Linter/Formatter&lt;/li&gt;
&lt;li&gt;Yes to Use class-style component syntax&lt;/li&gt;
&lt;li&gt;Yes to Use Babel alongside TypeScript for auto-detected polyfills&lt;/li&gt;
&lt;li&gt;TSLint as linter/formatter config&lt;/li&gt;
&lt;li&gt;Lint on save&lt;/li&gt;
&lt;li&gt;Config in dedicated config files&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;We can have a look at our newly created site if we navigate into the folder and perform an &lt;code&gt;npm install&lt;/code&gt; before running &lt;code&gt;npm run serve&lt;/code&gt;, nothing exciting but it should all work.&lt;/p&gt;
&lt;h2 id="dotnet-new"&gt;dotnet new&lt;/h2&gt;
&lt;p&gt;Next, we'll create an ASP.NET app using the Angular project template, again, at a suitable location in your favourite command prompt, type &lt;code&gt;dotnet new angular&lt;/code&gt;. We can open the project and run this in Visual Studio, and as if by magic we have an Angular app running from our ASP.NET project. If we take a look at the build output we should be able to see that an 'npm install' was initiated, this was from the additional target 'DebugEnsureNodeEnv’ in our project file, and if you look though the output for “ASP.NET Core Web Server” you should see that 'ng serve' was called, this call was initiated by the &lt;code&gt;spa.UseAngularCliServer(npmScript: "start")&lt;/code&gt; call in our startup.cs.&lt;/p&gt;
&lt;h2 id="bait-and-switch"&gt;bait and switch&lt;/h2&gt;
&lt;p&gt;Now let's replace the Angular ClientApp folder with the contents from the VueJs app created above, and the change the npmScript called by &lt;a href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.spaservices.angularcli.angularclimiddlewareextensions.useangularcliserver?view=aspnetcore-2.2"&gt;spa.UseAngularCliServer&lt;/a&gt; in Startup.cs from "start" to "serve" and see what happens when we run the ASP.NET app.&lt;/p&gt;
&lt;h2 id="fail"&gt;fail&lt;/h2&gt;
&lt;p&gt;Hmmmm.... not much, just the following exception:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;TimeoutException: The Angular CLI process did not start listening for requests within the timeout period of 50 seconds.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;But if we take another look at the outputs, we can see that our project has installed the npm packages and has actually started our Vue application on a random port, it would appear that the middleware just hasn't hooked everything up. Thankfully Microsoft has open sourced ASP.NET Core and much of the supporting packages so it doesn’t take much to rummage around the source code for &lt;a href="https://github.com/aspnet/AspNetCore/tree/master/src/Middleware/SpaServices.Extensions/src/AngularCli"&gt;AngularCliMiddleware&lt;/a&gt; to realise that the magic to hook everything up is simply a regular expression looking for the confirmation from the Angular CLI output.&lt;/p&gt;
&lt;h2 id="vueclimiddleware"&gt;VueCliMiddleware&lt;/h2&gt;
&lt;p&gt;So let's create our own middleware for Vue, looking though the source code it should be just a case of cloning the AngularCliMiddleware along with the internal supporting classes (unless of course you want to get creative with reflection) and use an appropriate regular expression to capture the Vue CLI start up.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Create a new, empty class lib project&lt;/li&gt;
&lt;li&gt;Add a package reference to &lt;a href="https://www.nuget.org/packages/Microsoft.AspNetCore.SpaServices.Extensions/2.2.0"&gt;Microsoft.AspNetCore.SpaServices.Extensions (2.2.0)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Copy AngularCliBuilder.cs, AngularCliMiddleware.cs and AngularCliMiddlewareExtensions.cs and supporting internal classes from &lt;a href="https://github.com/aspnet/AspNetCore"&gt;https://github.com/aspnet/AspNetCore&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Rename all the things&lt;/li&gt;
&lt;li&gt;Replace openBrowserLine Regex with a suitable Vue alternative, I went for &lt;code&gt;" - Local: (http\\S+)"&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;You can now reference this project in any project created from the Angular template after swapping out the Angular ClientApp with you Vue ClientApp and simply change the &lt;code&gt;spa.UseAngularCliServer(npmScript: "start")&lt;/code&gt; with &lt;code&gt;spa.UseVueCliServer(npmScript: "serve");&lt;/code&gt;&lt;/p&gt;
&lt;h2 id="heres-one-i-made-earlier"&gt;Here's one I made earlier&lt;/h2&gt;
&lt;p&gt;You can check out the version I knocked up &lt;a href="https://github.com/Nyami/AspNetCore.VueCliServices"&gt;here&lt;/a&gt;, this has also been uploaded to &lt;a href="https://www.nuget.org/packages/Nyami.AspNetCore.VueCliServices"&gt;NuGet&lt;/a&gt; so you can get started by pulling this into your own project via the package manager UI or the package manager console using &lt;code&gt;Install-Package Nyami.AspNetCore.VueCliServices&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;In the &lt;a href="https://www.nyami.uk/posts/2019-06-11-VueWithAspNetPart3"&gt;next part&lt;/a&gt; we'll take a look at creating a project template to get us up and running even quicker.&lt;/p&gt;
</content>
		<summary>Something interesting for sure...</summary>
	</entry>
	<entry>
		<id>https://www.nyami.uk/posts/2019-05-10-vuewithaspnetpart1</id>
		<title>VueJs and ASP.NET Core - Part 1</title>
		<link href="https://www.nyami.uk/posts/2019-05-10-vuewithaspnetpart1" />
		<link rel="enclosure" type="image" href="https://www.nyami.uk/images/VueLogo.png" />
		<updated>2019-05-10T00:00:00Z</updated>
		<content>&lt;p&gt;Whilst it’s relatively easy to &lt;a href="http://lmgtfy.com/?q=asp.net+core+2+with+vue"&gt;find and follow a guide&lt;/a&gt; to get up and running with Vue and ASP.NET Core, you’ll probably find there are a number techniques, methods, and opinions and there isn’t really the ‘first class’ support and 'simple' method of getting started as there is with Angular. In the following series of posts we’ll take a look at repurposing and using some of Microsoft’s SpaServices to create better support for Vue.js within your new ASP.NET Core project.&lt;/p&gt;
&lt;!--more--&gt;
&lt;h2 id="dotnet-new-angular"&gt;dotnet new angular&lt;/h2&gt;
&lt;p&gt;Before we get started creating our own stuff for Vue lets look at creating an Angular project using the &lt;a href="https://www.nuget.org/packages/Microsoft.DotNet.Web.Spa.ProjectTemplates/"&gt;Microsoft's template&lt;/a&gt; and see what it gives us.&lt;/p&gt;
&lt;p&gt;Assuming you have the &lt;a href="https://dotnet.microsoft.com/download"&gt;.NET Core SDK&lt;/a&gt; installed (tested with 2.2), at a location of your choosing, drop to your preferred terminal and type &lt;code&gt;dotnet new angular&lt;/code&gt;. We now have a fairly sparse, and if you've worked with ASP.NET, familiar, project created. Let's break it down a little:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;ClientApp folder - a Hello World Angular app&lt;/li&gt;
&lt;li&gt;Controllers folder - contains a simple api to 'fetch' weather data&lt;/li&gt;
&lt;li&gt;Pages folder - not much here, just the Error page (MVC)&lt;/li&gt;
&lt;li&gt;Properties folder - launchsettings used for debug/development&lt;/li&gt;
&lt;li&gt;wwwroot folder - static assets for the side&lt;/li&gt;
&lt;li&gt;appsettings.json - application setting, appsettings.development.json allows for development time settings&lt;/li&gt;
&lt;li&gt;Foo.csproj - the aspnet project file, more information below&lt;/li&gt;
&lt;li&gt;Program.cs - application entry point&lt;/li&gt;
&lt;li&gt;Startup.cs - Configures services and application request pipeline&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;If you want to learn more about ASP.NET Core apps the &lt;a href="https://docs.microsoft.com/en-us/aspnet/core/fundamentals/?view=aspnetcore-2.2"&gt;official documentation&lt;/a&gt; is the best place to head.&lt;/p&gt;
&lt;h2 id="startup.cs"&gt;Startup.cs&lt;/h2&gt;
&lt;p&gt;As with most ASP.NET applications the magic is coordinated in Startup.cs, there are typically two main parts, &lt;code&gt;ConfigureServices&lt;/code&gt;, where we configure and register services required by our application, and &lt;code&gt;Configure&lt;/code&gt;, where we configure the request handling pipeline. If you open Startup.cs you'll see the template has added some SPA related code to each of these methods.&lt;/p&gt;
&lt;p&gt;In the first block of code, as well as adding MVC configuration, it adds configuration telling the middleware where to expect to find the files for the SPA application.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;// This method gets called by the runtime. Use this method to add services to the container.
public void ConfigureServices(IServiceCollection services)
    {
    services.AddMvc().SetCompatibilityVersion(CompatibilityVersion.Version_2_2);

    // In production, the Angular files will be served from this directory
    services.AddSpaStaticFiles(configuration =&amp;gt;
    {
        configuration.RootPath = "ClientApp/dist";
    });
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;In this next block we can see there are two points of interest for our application, &lt;code&gt;app.UseSpaStaticFiles()&lt;/code&gt;, which uses the configuration above to serve the static files for the SPA and &lt;code&gt;app.UseSpa&lt;/code&gt; which will return the default SPA page for any unhandled requests, its important this is the last middleware in our pipeline as it essentially acts as a 'catch all' on the assumption the route will be matched by our client side app. You can also see that when in development there is a call &lt;code&gt;spa.UseAngularCliServer(npmScript: "start")&lt;/code&gt;, this will call the npm script specified, wait for it to start successfully, and will 'proxy' calls in to the webpack web server started, and is what we'll go on to replicate for our Vue implementaion.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;public void Configure(IApplicationBuilder app, IHostingEnvironment env)
{
    // Code removed for brevity

    app.UseSpaStaticFiles();

    app.UseMvc(routes =&amp;gt; {
        //Code removed for brevity
    });

    app.UseSpa(spa =&amp;gt;
    {
        // To learn more about options for serving an Angular SPA from ASP.NET Core,
        // see https://go.microsoft.com/fwlink/?linkid=864501

        spa.Options.SourcePath = "ClientApp";

        if (env.IsDevelopment())
        {
            spa.UseAngularCliServer(npmScript: "start");
        }
    });
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id="csproj-file"&gt;.csproj file&lt;/h2&gt;
&lt;p&gt;The project file has a couple of extra targets when compared to a vanilla MVC project file, these are used to assert that npm has been installed when the project is being built and another target is used to add our Angular application to the published output. The project also ensures the ClientApp folder is not handled as part of the default build and publish behaviour.&lt;/p&gt;
&lt;h2 id="but-what-about-vue"&gt;But what about Vue?&lt;/h2&gt;
&lt;p&gt;Looking at what Microsoft's template provides this is the exact experience we are hoping to achieve but for Vue. There are really two parts to the Angular and ASP.NET Core story, the SPA middleware that hooks up Webpack at development time and serves the SPA’s static files, and the template getting us up and running ensuring a consistent experience. In the next part we'll take a look at the middleware and see how far it can take us for Vue.&lt;/p&gt;
&lt;p&gt;&lt;a href="https://www.nyami.uk/posts/2019-05-21-VueWithAspNetPart2"&gt;Part 2&lt;/a&gt;&lt;/p&gt;
</content>
		<summary>Something interesting for sure...</summary>
	</entry>
	<entry>
		<id>https://www.nyami.uk/posts/2019-05-03-mics-camera-action</id>
		<title>Mics, Camera, Action!</title>
		<link href="https://www.nyami.uk/posts/2019-05-03-mics-camera-action" />
		<link rel="enclosure" type="image" href="https://www.nyami.uk/images/BoxOfTricks.jpg" />
		<updated>2019-05-03T00:00:00Z</updated>
		<content>&lt;p&gt;At the end of last year we ran a successful &lt;a href="https://www.gofundme.com/aberdeen-developers-net-user-group"&gt;funding campaign&lt;/a&gt; at Aberdeen Developers .NET User Group to purchase some gear to allow us to record some of our sessions. We had a good idea of what we were wanting to achieve, essentially, we wanted to be able to publish recordings of our sessions and we weren’t wanting to spend hours processing the content after the recording. With a couple of events successfully in the bag I thought it might be worth sharing our setup, so here it is...&lt;/p&gt;
&lt;!--more--&gt;
&lt;p&gt;Most of the magic is done using &lt;a href="https://obsproject.com/"&gt;Open Broadcaster Software (OBS)&lt;/a&gt;, a free and open-source streaming and recording program, but before we dive into our config let’s run down our hardware.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Microphones, probably one of the most important things for me, personally I can’t follow any video with poor sound. We have a &lt;a href="https://www.amazon.co.uk/gp/product/B07F3KLX14"&gt;wireless lapel mic&lt;/a&gt; for the speaker and a &lt;a href="https://www.amazon.co.uk/gp/product/B07F3V3LD2"&gt;wireless handheld mic&lt;/a&gt; for the host&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.amazon.co.uk/gp/product/B01DRWCOGA"&gt;Elgato Game Capture HD60 S&lt;/a&gt;, this is an awesome bit of kit, it allows us to capture the output from the presenter's laptop without having to install anything on their laptop, we also have an HDMI splitter just in case any DRM protection interferes with the process, but we've not encountered this&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.amazon.co.uk/gp/product/B006A2Q81M"&gt;Logitech C920 HD Pro Webcam&lt;/a&gt; mounted on a tripod just to make things a little more interesting to watch&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.amazon.co.uk/gp/product/B06W2KLM3S"&gt;Elgato Stream Deck&lt;/a&gt; to make scene selection nice and simple&lt;/li&gt;
&lt;li&gt;A good selection of cables, USB, HDMI and power cables as well as a USB hub to keep thing tidy&lt;/li&gt;
&lt;/ul&gt;
&lt;img src="/images/ADNUGRecordingGear.jpg" alt="A selection of stuff" style="width:250px;"/&gt;
&lt;p&gt;As mentioned above OBS provides much of the magic, each of the input sources above can be toggled in OBS. We have 3 different scenes; presentation, web cam directed at the speaker, and a composite of the two, which we can cycle through depending on how the presentation is going, we can also toggle each of the microphones as required. OBS can record and stream via two separate controls within the application, we have OBS setup to stream to &lt;a href="https://www.twitch.tv/adnuguk"&gt;Twitch&lt;/a&gt; and record to disc, thankfully both have worked well on the night. Once recorded we only have to put the recording though ffmpeg trimming as required before uploading to our &lt;a href="https://www.youtube.com/channel/UCRnxcmrSrc4TWKqakE4EViw"&gt;YouTube channel&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;We'll hopefully get a few more sessions recorded so make sure subscribe to &lt;a href="https://www.youtube.com/channel/UCRnxcmrSrc4TWKqakE4EViw"&gt;YouTube channel&lt;/a&gt; so you don't miss out. If you are interested in setting something similar up and have questions please reach out if I can be of any help.&lt;/p&gt;
</content>
		<summary>Something interesting for sure...</summary>
	</entry>
	<entry>
		<id>https://www.nyami.uk/posts/2019-03-03-custom-http-verb</id>
		<title>Custom HTTP Verb</title>
		<link href="https://www.nyami.uk/posts/2019-03-03-custom-http-verb" />
		<updated>2019-03-03T00:00:00Z</updated>
		<content>&lt;p&gt;There are server reasons you might look to implement a custom HTTP Verb in you ASP.NET application, and thankfully with ASP.NET Core it’s incredibly simple.&lt;/p&gt;
&lt;!--more--&gt;
&lt;p&gt;Here is a nice simple example of a WEBDAV inspired SEARCH verb, potentially useful if you’re encountering limitations of GET, perhaps because you can't have a GET with body, hitting the URL length limit, or just want to have consistent verb.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class HttpSearchAttribute : HttpMethodAttribute {

        private static readonly IEnumerable&amp;lt;string&amp;gt; SupportedMethods = new[] { &amp;quot;SEARCH&amp;quot; };

        public HttpSearchAttribute() : base(SupportedMethods) {
        }

        public HttpSearchAttribute(string template) : base(SupportedMethods, template) {
            if (string.IsNullOrWhiteSpace(template)) {
                throw new ArgumentNullException(nameof(template));
            }
        }
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Once you have your custom attribute you can apply this to any controller action and start using your verb.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// SEARCH api/values
[HttpSearch]
public ActionResult&amp;lt;IEnumerable&amp;lt;string&amp;gt;&amp;gt; Search([FromBody] string value) {
    return values.Where(v =&amp;gt; v.Contains(value)).ToList();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;A fully working, simple example is located over at &lt;a href="https://github.com/Nyami/WebApiSearchMethod"&gt;GitHub&lt;/a&gt;&lt;/p&gt;
</content>
		<summary>Something interesting for sure...</summary>
	</entry>
	<entry>
		<id>https://www.nyami.uk/posts/2019-03-02-blog-20</id>
		<title>Blog 2.0</title>
		<link href="https://www.nyami.uk/posts/2019-03-02-blog-20" />
		<updated>2019-03-02T00:00:00Z</updated>
		<content>&lt;p&gt;I think I have more blog post about setting up blogs than I have on anything else, and its been a while since the last one so I thought it about time for another one. I like the concept of static generation for blogs and first incarnations used Octopress, a blogging framework based on Jekyll, but the workflow and content produced wasn’t really working for me so it was time for a change.&lt;/p&gt;
&lt;!--more--&gt;
&lt;p&gt;I decided to look at &lt;a href="https://wyam.io/"&gt;Wyam&lt;/a&gt;, I knew of a few folks using it and as it using .NET and Razor much of it had a familiar feel I was comfortable with. I’m not going to go into detail on setting it up, their site has comprehensive coverage on &lt;a href="https://wyam.io/docs/usage/"&gt;getting started&lt;/a&gt;, using &lt;a href="https://wyam.io/docs/deployment/appveyor"&gt;Github Pages and AppVeyor&lt;/a&gt; for deployment. I did start off trying to be smart and automate the markdown conversion but the reality was I didn’t have much so opted for the manual approach. Hopefully I’ll have a couple of useful posts before the next blog post and blogs posts.&lt;/p&gt;
</content>
		<summary>Something interesting for sure...</summary>
	</entry>
	<entry>
		<id>https://www.nyami.uk/posts/2018-08-17-dotnet-sln-add</id>
		<title>dotnet sln add</title>
		<link href="https://www.nyami.uk/posts/2018-08-17-dotnet-sln-add" />
		<updated>2018-08-17T09:02:03Z</updated>
		<content>&lt;p&gt;It's been a while since I'd created a number dotnet projects and supporting solution using the command line so I had to refer to the &lt;a href="https://docs.microsoft.com/en-us/dotnet/core/tools/dotnet"&gt;documentation&lt;/a&gt; to keep me right. As I had just created a number of projects adding each one to the solution is a little tedious so when I'd spotted I could use &lt;a href="https://en.wikipedia.org/wiki/Glob_(programming)"&gt;globbing patterns&lt;/a&gt; I thought this would save time and a few key presses.&lt;/p&gt;
&lt;!--more--&gt;
&lt;p&gt;However, when I ran &lt;code&gt;dotnet sln Foo.sln add **/*.csproj&lt;/code&gt; I was presented with the error &lt;code&gt;Could not find project or directory **/*.csproj&lt;/code&gt;. It turns out that globbing is not actually supported by the CLI but actually a shell feature and PowerShell wasn't expanding the glob. Luckly as dotnet is cross platform and I have &lt;a href="https://docs.microsoft.com/en-us/windows/wsl/install-win10"&gt;Windows Subsystem for Linux&lt;/a&gt; installed with all the dotnet goodness I could switch to &lt;code&gt;bash&lt;/code&gt;, ensure globbing was enabled using &lt;code&gt;shopt -s globstar&lt;/code&gt;, and then run &lt;code&gt;dotnet sln Foo.sln add **/*.csproj&lt;/code&gt; to add all my new projects, job done...&lt;/p&gt;
</content>
		<summary>Something interesting for sure...</summary>
	</entry>
</feed>